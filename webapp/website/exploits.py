# exploits.py Handles most vulnerabilities within the application
# Standard library imports
# Third-party imports

from flask import Blueprint, render_template, request, jsonify, current_app, flash, redirect, url_for, abort, send_file, Response
from flask_login import login_required
from . import db
from flask_login import current_user
import os
from urllib.parse import unquote
import logging
from .models import Note
from werkzeug.utils import secure_filename
import magic #HAD to install Magic/ pip install python-magic-bin
import subprocess
import time
import stat
import mimetypes


exploits = Blueprint('exploits', __name__)

logging.basicConfig(level=logging.DEBUG)


# === XSS Level 1: No sanitization ===
@exploits.route('/XSS-1', methods=['GET', 'POST']) # route pointing to XSS-1 page
@login_required
def exploitXSS1():
    name = None
    message = None
    if request.method == 'POST':
        name = request.form.get("name", "") # user input from form
        message = request.form.get("message", "")
        logging.debug(f"User input received: name={name}, message={message}")
    else:
        logging.debug("GET request received")
        # Passes input to template
    return render_template('XSS-1.html', name=name, message=message, user=current_user) 


# === XSS Level 2: Minimal sanitization (only removes exact <script>) ===
@exploits.route('/XSS-2', methods=['GET', 'POST']) # route pointing to XSS-2 page
@login_required
def exploitXSS2():
    name = None
    message = None
    if request.method == 'POST':
        name = request.form.get('name', '')
        message = request.form.get('message', '')
        name = name.replace('<script>', '') 
        logging.debug(f"User input received: {name}")
        '''
     minimal sanitisation: Remove "<script>" but only filters by exact pattern matching 
     such as <SCRIPT> and allowing other dangerous tags
        '''
    else:
        logging.debug("GET request received")
    logging.debug(f"Rendering template with name: {name}, message: {message}")
    return render_template('XSS-2.html', name=name, message=message, user=current_user)


# === XSS Level 3: Regex-based sanitization, still bypassable ===
@exploits.route('/XSS-3', methods=['GET', 'POST']) # route pointing to XSS-3 page
@login_required
def exploitXSS3():
    name = None
    message = None
    if request.method == 'POST':
        name = request.form.get('name', '')
        message = request.form.get('message', '')
       #user_input = escape(user_input)
        name = name.replace(r'(?i)<script.*?>.*?</script>', '')
        logging.debug(f"User input received: {name}")
        '''
     medium sanitisation: Removes "<script>" using pattern matching using wildcards to 
     filter by all modifications of <script> tag but still allows other dangerous tags
        '''
    else:
        logging.debug("GET request received")
    logging.debug(f"Rendering template with user_input. Name: {name}, Message: {message}")
    return render_template('XSS-3.html', name=name, message=message, user=current_user)


# === Index page for Exploits ===
@exploits.route('/') # route pointing to / page
def index():
    return render_template('intro.html', user=current_user)


# === Directory Traversal static info/demo page ===
@exploits.route('/Traversal', methods=['GET', 'POST']) # route pointing to Directory traversal page
def exploit3():
    return render_template('Traversal.html', user=current_user)


# === Static IDOR overview page ===
@exploits.route('/IDOR') # route pointing to IDOR page
def IDOR():
    return render_template('IDOR.html', user=current_user)


# === Static SQL Injection demo page ===
@exploits.route('/SQL') # route pointing to SQL Injection page
def SQLI_vuln():
    return render_template('SQL.html', user=current_user)


# === File Upload Level 1: No sanitization, path traversal, allows arbitrary files ===
@exploits.route("/file-upload1", methods=["GET", "POST"]) # route pointing to file-upload 1 page
@login_required
def upload_file1():
    file_uploaded = None  # Variable to hold the success message
    if request.method == 'POST':
        file = request.files['file']

        # directly using the filename from user input, allowing directory traversal
        filename = file.filename

        upload_folder = os.path.join(current_app.root_path, 'static', 'uploads')
        os.makedirs(upload_folder, exist_ok=True)

        # it might write outside the intended folder
        file.save(os.path.join(upload_folder, filename))
        file_uploaded = f'File uploaded: {filename}'
        
        # Return the same template with the success message
        return render_template('file-upload1.html', user=current_user, file_uploaded=file_uploaded)
    
    return render_template('file-upload1.html', user=current_user)


ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}
DISALLOWED_EXTENSIONS = {'php', 'py', 'exe', 'sh', 'pl', 'js'}
MAX_FILE_SIZE = 1000000 #allows 1MB upload file


def allowed_file(filename):
    """
    validates only allowed file extensions are uploaded
    Allow only single, clean image extensions.
    Reject files with multiple extensions where any part is dangerous.
    """
    if '.' not in filename:
        return False

    parts = filename.lower().split('.')

    # Check all parts (including last) for disallowed extensions
    for ext in parts:
        if ext in DISALLOWED_EXTENSIONS:
            return False

    # Only allow the final extension to be one of the approved types
    return parts[-1] in ALLOWED_EXTENSIONS



def allowed_mime_type(file):
    """Check if the uploaded file is a valid image type."""
    mime = magic.Magic(mime=True)  # Initialize magic for MIME type detection
    file_mime = mime.from_buffer(file.stream.read(2048))  # Read first 2 KB
    file.stream.seek(0)  # Reset file pointer after reading

    # Define allowed MIME types
    allowed_mime_types = {'image/png', 'image/jpeg', 'image/jpg'}
    
    return file_mime in allowed_mime_types


# === File Upload Level 2: Extension + size check, but vulnerable to double extensions ===
@exploits.route("/file-upload2", methods=["GET", "POST"]) # route pointing to file-upload 2 page
# Powershell change filename to shell.php.jpg
@login_required
def upload_file2():
    file_uploaded = None  # Variable to hold success or error messages
    if request.method == "POST" and "file" in request.files:
        file = request.files["file"]
        file.seek(0, os.SEEK_END)  # moves cursor to end of file to get size
        file_size = file.tell()  # gets the file size
        file.seek(0)  # resets cursor position to beginning
        if file.filename == "":
            file_uploaded = 'File was not uploaded'
        elif not allowed_file(file.filename):
            file_uploaded = 'Invalid file type!. Only PNG, JPG, JPEG'
        elif file_size > MAX_FILE_SIZE:
            file_uploaded = "File is too large. Max size is 10 KB."       
        else:
            # maybe not use file.filename as it blocks directory traversal
            filename = secure_filename(file.filename)  
            
            upload_folder = os.path.join(current_app.root_path, 'static', 'uploads')
            os.makedirs(upload_folder, exist_ok=True)  # Ensure directory exists

            file.save(os.path.join(upload_folder, filename))
            file_uploaded = f'File uploaded: {file.filename}'
    return render_template('file-upload2.html', user=current_user, file_uploaded=file_uploaded)
    

# === File Upload Level 3: MIME + extension check, but race condition and polyglot vulnerability ===
@exploits.route("/file-upload3", methods=["GET", "POST"])
@login_required
def upload_file3():
    file_uploaded = None  # Variable to hold success or error messages
    if request.method == 'POST':
        file = request.files['file']

        file.seek(0, os.SEEK_END)  # Move cursor to end of file to get size
        file_size = file.tell()  # Get the file size
        file.seek(0)  # Reset cursor position to beginning for further processing

        if file.filename == "":
            file_uploaded = 'File was not uploaded'
        elif not allowed_file(file.filename):
            file_uploaded = 'Invalid file type!. Only PNG, JPG, JPEG'
        elif file_size > MAX_FILE_SIZE:
            file_uploaded = "File is too large. Max size is 1MB."  
        elif not allowed_mime_type(file):
            file_uploaded = "Invalid MIME type"
        else:
            filename = secure_filename(file.filename)

            # Only checking MIME and extension
            if not allowed_file(filename) or not allowed_mime_type(file):
                file_uploaded = 'Invalid file type!'
            else:
                upload_folder = os.path.join(current_app.root_path, 'static', 'uploads')
                os.makedirs(upload_folder, exist_ok=True)  # Ensure directory exists
                save_path = os.path.join(upload_folder, filename)
                file.save(save_path)

                # Dangerous behavior: server later processes this file in insecure ways,
                # like reading EXIF metadata or trusting user image content.

                file_uploaded = f'File uploaded and processed: {filename}'
    return render_template('file-upload3.html', user=current_user, file_uploaded=file_uploaded)



def is_python_script(file_path): 
    # checks if the file is a python script by reading the first line
    try:
        with open(file_path, "rb") as f:
            first_line = f.readline().decode(errors="ignore") # reads the first line to check for a python shebang
        return first_line.startswith("#!") or "python" in first_line.lower() # detect if the script starts with python
    except Exception:
        return False # returns false if an error occurs

def extract_hidden_script(file_path):
    """Extracts the hidden Python script from a polyglot file (JPEG + Python)."""
    try:
        with open(file_path, "rb") as f:
            content = f.read()

        # Detect the start of Python code (e.g., first occurrence of '#!')
        script_start = content.find(b'#!/usr/bin/python3')
        if script_start == -1:
            return None  # No script found

        # Extract everything after the detected script start
        script_content = content[script_start:].decode(errors="ignore")

        # Save extracted script temporarily
        extracted_script_path = file_path + ".py"
        with open(extracted_script_path, "w") as script_file:
            script_file.write(script_content)

        return extracted_script_path
    except Exception:
        return None  # Extraction failed


# === File Execution and Directory traversal Level 1: Allows direct execution of uploaded .py files ===
@exploits.route("/view-upload1")  # /etc/passwd to bypass
def view_uploaded_file():
    filename = request.args.get("file")
    if not filename:
        return "Filename not provided", 400

    upload_folder = os.path.join(current_app.root_path, "static", "uploads")
    file_path = os.path.join(upload_folder, filename)

    if not os.path.exists(file_path):
        return "File not found", 404

    # Use `magic` to detect MIME type
    mime = magic.Magic(mime=True)
    file_mime_type = mime.from_file(file_path)

    # **Case 1: Execute a standalone Python script (.py)**
    if file_mime_type in ["text/x-python", "application/x-python-code"] or is_python_script(file_path):
        try:
            # Set execute permissions
            st = os.stat(file_path)
            os.chmod(file_path, st.st_mode | stat.S_IXUSR)

            # Execute the script
            result = subprocess.run(["python3", file_path], capture_output=True, text=True, timeout=5)

            return f"<pre>{result.stdout}</pre><pre>{result.stderr}</pre>"
        except subprocess.TimeoutExpired:
            return "Error: Script execution timed out", 500
        except Exception as e:
            return f"Error: {str(e)}", 500

    # **Case 2: Check if it's an image with a hidden Python script**
    if file_mime_type.startswith("image/"):
        extracted_script = extract_hidden_script(file_path)
        
        if extracted_script:
            try:
                # Set execute permissions on the extracted script
                st = os.stat(extracted_script)
                os.chmod(extracted_script, st.st_mode | stat.S_IXUSR)

                # Execute extracted script
                result = subprocess.run(["python3", extracted_script], capture_output=True, text=True, timeout=5)

                return f"<pre>{result.stdout}</pre><pre>{result.stderr}</pre>"
            except subprocess.TimeoutExpired:
                return "Error: Script execution timed out", 500
            except Exception as e:
                return f"Error: {str(e)}", 500

        # **If no script is found, display the image instead**
        return send_file(file_path, mimetype=file_mime_type)

    # **Case 3: Serve other files as plain text**
    return send_file(file_path, mimetype="text/plain", as_attachment=False)


# === Directory Traversal Level 2: Single encoding + basic slash removal ===
@exploits.route('/view-upload2')
@login_required
def view_file2():
    # get decoded file param
    file_path = request.args.get('file')
    if not file_path:
        abort(404)

    """
     request original string before decoded by request.args.get parameeter automatically and 
     .decode decodes the query string into a normal python string
     """
    raw_query = request.query_string.decode()
    
    # Block raw slashes in query string (e.g., /etc/passwd)
    if '/' in raw_query:
        abort(403)

    # Decode once (e.g., %2Fetc%2Fpasswd becomes /etc/passwd)
    decoded_path = unquote(file_path)

    # If the file path is not absolute, prepend the uploads directory
    if not os.path.isabs(decoded_path):
        base_dir = os.path.join(current_app.root_path, 'static', 'uploads')
        final_path = os.path.join(base_dir, decoded_path)
    else:
        final_path = decoded_path

    try:
        # Try to open the file as text
        with open(final_path, 'r') as f:
            content = f.read()

        # If successful, return the content as plain text (inline display)
        return Response(content, mimetype='text/plain',
                        headers={'Content-Disposition': 'inline'})

    except Exception as e:
        # Fallback: if it's binary or unreadable as text
        print(f"[DEBUG - fallback to binary send] {e}")

        try:
            # Guess MIME type
            mime_type, _ = mimetypes.guess_type(final_path)

            # Serve the file as binary (image, PDF, etc.)
            return send_file(final_path, mimetype=mime_type, as_attachment=False)

        except Exception as e2:
            print(f"[DEBUG - file not found or unreadable: {e2}]")
            abort(404)

# === Directory Traversal Level 3: Double encoding bypass with weak sanitization ===
@exploits.route('/view-upload3')
@login_required
def view_file3():
    file_path = request.args.get('file')
    if not file_path:
        abort(404)

    """
     request original string before decoded by request.args.get parameeter automatically and 
     .decode decodes the query string into a normal python string
     """
    raw_query = request.query_string.decode()

    # blocks any raw slashes (like /etc/passwd) or single URL encoded (%2Fetc%2Fpasswd)
    if '/' in raw_query or '%2f' in raw_query.lower():
        abort(403)

    # Level 3: Decode double URL-encoded input. 
    once_decoded = unquote(file_path)        # %252Fetc%252Fpasswd to %2Fetc%2Fpasswd
    decoded_path = unquote(once_decoded)     # %2Fetc%2Fpasswd to /etc/passwd

    # # If the file path is not absolute, prepend the uploads directory.
    if not os.path.isabs(decoded_path):
        base_dir = os.path.join(current_app.root_path, 'static', 'uploads')
        final_path = os.path.join(base_dir, decoded_path)
    else:
        final_path = decoded_path

    try:
        # Try to open the file as text
        with open(final_path, 'r') as f:
            content = f.read()

        # If successful, return the content as plain text (inline display)
        return Response(content, mimetype='text/plain',
                        headers={'Content-Disposition': 'inline'})

    except Exception as e:
        # Fallback: if it's binary or unreadable as text
        print(f"[DEBUG - fallback to binary send] {e}")

        try:
            # Guess MIME type
            mime_type, _ = mimetypes.guess_type(final_path)

            # Serve the file as binary (image, PDF, etc.)
            return send_file(final_path, mimetype=mime_type, as_attachment=False)

        except Exception as e2:
            print(f"[DEBUG - file not found or unreadable: {e2}]")
            abort(404)


# === IDOR Level 1: No ownership check at all ===
@exploits.route('/view-note1/<int:note_id>')
def view_note1(note_id):
    # Retrieves the note by its ID, with NO ownership or login checks
    note = Note.query.get(note_id)  # Vulnerable: anyone can access any note if they know the I
    if note:
        return render_template('view_note.html', note=note, user=current_user)
    else:
        flash("Note not found or you don't have permission to view this note", category='error')
        return redirect(url_for('views.notes'))


# === IDOR Level 2: Login required, but no ownership check ===
@exploits.route('/view-note2/<int:note_id>')
@login_required  # User must be logged in to access this route
def view_note2(note_id):
    # Retrieves the note by its ID, still no ownership validation
    note = Note.query.filter_by(id=note_id).first()
    if note:
        # FAKE validation: user_id is always >= 0 if the note exists
        if note.user_id >= 0:  # This logic does nothing meaningful for security
            return render_template('view_note.html', note=note, user=current_user)

    flash("Note not found or you don't have permission", category="error")
    return redirect(url_for('views.notes'))


# === IDOR Level 3: Ownership bypass via user_id parameter ===
@exploits.route('/view-note3/<int:note_id>')
@login_required  # User must be logged in
def view_note3(note_id):
    # Attacker can supply a user_id in the URL to bypass ownership checks
    forced_user_id = request.args.get("user_id", type=int)
    # Retrieves note from database
    note = Note.query.get(note_id)
    # Allows access if:
    #   - The current user owns the note, OR
    #   - The attacker supplies a matching user_id via the query string
    if note and (note.user_id == current_user.id or note.user_id == forced_user_id):
        return render_template('view_note.html', note=note, user=current_user)
    flash("You don't have access to this note", category="error")
    return redirect(url_for('views.notes'))